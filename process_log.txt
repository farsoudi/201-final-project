Hailey, Login Page
Prompt:
Using these technical specifications for my study spot finder website, walk me through the steps to build the login page.​

Issues:
It was unclear where to start (backend versus frontend), and there was no existing login endpoint or user model.​

Fixes:
A complete flow was defined: create a backend /login endpoint and user storage that issues a JWT, then build a React login form to call it.​

Explanation:
This established the overall architecture (Spring Boot + JWT + React) and became the foundation for all later authentication work on the login page.​

Prompt:
I am working on the front end part only.​

Issues:
The responsibilities between frontend and backend were unclear, and the toolchain for the login page (React app, Node) needed to be confirmed.​

Fixes:
A plan was made to set up a React app with Vite and build a standalone login form component that would POST to a future backend login URL, with email/password fields and client‑side validation.​

Explanation:
This scoped your work to React, local validation, and fetch calls, letting teammates own Spring Boot and MySQL while you focused on the login UI.​

Prompt:
Can you add it for me (asking to add token handling to the login component that switches between login and signup modes).​

Issues:
The UI for login/signup existed, but the returned token was not being stored anywhere on the frontend.​

Fixes:
Inside handleSubmit, code was added to parse the JSON response, read the token, and save it to localStorage under a consistent key such as "token".​

Explanation:
Storing the token in localStorage enabled later API helper functions to read it and send Authorization: Bearer <token> on protected requests, completing the basic auth flow from the login page.​

Prompt:
Is the login page still correct? (for LoginPage.js after resolving merge conflicts).​

Issues:
A stray Git hash line remained in the file and useContext was used without being imported, causing compile errors.​

Fixes:
The stray hash line was removed and the import was changed to import { useState, useContext } from "react"; while keeping AuthContext usage.​

Explanation:
These fixes restored a compiling React login component that continued to work with the auth context after the merge.​

Prompt:
I just finished the login/signup function into backend. Now I need to make sure that FRONTEND correctly uses this new authentication mechanism, particularly ensuring we attach an Authorization: Bearer <token> header on all our API calls. How do I do this?​

Issues:
The backend was returning a token, but other frontend API calls were not reusing it, and some pages were still calling fetch directly.​

Fixes:
A pattern was chosen where token reading and Authorization: Bearer <token> headers live inside API helper modules (like favorites.js, reviews.js, and spots.js), and pages call helpers such as getFavorites() instead of managing headers themselves.​

Explanation:
Centralizing token handling in API helpers kept components simpler and tied the login page’s stored token cleanly to all protected backend requests.​

Prompt:
Ok do I need to do the same to the other auth js pages?​

Issues:
It was unclear which files actually needed the token header, creating a risk of adding Authorization to endpoints that do not require login (like /login or /register).​

Fixes:
It was clarified that only helpers calling protected endpoints (favorites, reviews, spots, and future /api/me‑style endpoints) should add the token, while plain /login and /register must not send Authorization.​

Explanation:
This decision documented exactly where the login page’s token was required and avoided unnecessary headers on public endpoints.​

Prompt:
Is it the profile page that I need to import? If yes please make edits.​

Issues:
There was confusion about whether ProfilePage needed to use the token or import auth helpers, even though it had only hardcoded placeholder data.​

Fixes:
It was confirmed that ProfilePage did not yet need token or API imports and would only use a helper like getCurrentUser() once a real /api/me endpoint existed.​

Explanation:
This kept token usage limited to components that actually talk to the backend, preserving a clean separation between login/auth logic and purely presentational pages.​

Prompt:
Modify for me (login.html with navbar and logout).​

Issues:
The original HTML login page had minimal frontend validation and did not disable the login button or show clear inline error messages.​

Fixes:
Username and password length checks were added before the fetch call, the login button was disabled during submission, and result messages were displayed in a dedicated area instead of relying only on alerts.​

Explanation:
These changes made the early non‑React login page more robust and user‑friendly, and the same validation ideas later informed your React login component.​

Prompt:
Make modifications (to login.html) so it integrated with main.js.​

Issues:
Login/logout logic was duplicated between the page and main.js, and navbar state (login link vs logout button) was inconsistent.​

Fixes:
The login JS was updated so successful login called setLoggedIn(username) from main.js, logout reused shared logic, and the navbar contained only one login link with consistent IDs.​

Explanation:
Unifying behavior through main.js made the classic login page consistent with shared state management across pages.​

Prompt:
Here is my login, consolidate it for me (merge login and signup into one HTML page).​

Issues:
Having separate login.html and signup.html caused duplication and different redirects and navigation behavior.​

Fixes:
Both forms were merged into a single Login / Sign Up page with side‑by‑side sections, navigation was standardized (Home linking to index.html), and both flows redirected consistently after success.​

Explanation:
This consolidation simplified the authentication UI and mirrored the later React approach where the login component switches between login and signup modes on one screen.​


Riya, Study Spot Map

Prompt:
Create a map view page using React Leaflet that shows an interactive map centered around USC with markers for study spots, and integrate this page into the main navigation so users can reach it from the login/home flow.​

Issues:
It was unclear how to structure the React Leaflet components (MapContainer, TileLayer, and markers) within the existing React app and routing.​
There was some uncertainty about what center coordinates and zoom level to use for the USC area so that the campus filled the initial view appropriately.​

Fixes:
A dedicated MapView React component was created using MapContainer and TileLayer from React Leaflet, with the center set to approximate USC’s coordinates and a zoom level that shows the campus and nearby study spots.​
The MapView component was added to the router and nav so that clicking the “Map” or “Map View” link loads this Leaflet map while keeping the shared layout and header consistent.​

Explanation:
Building the map page with React Leaflet isolated all mapping logic in one component and made it straightforward to later add markers, popups, and filters for study spots while fitting cleanly into the existing navigation and routing.​

Prompt:
Style the Leaflet map view page with a dedicated CSS file so the map fills the main content area, stays responsive on different devices, and leaves room for any side or bottom panels.​

Issues:
Initially the Leaflet map container did not have a fixed height, so the map either collapsed to zero height or appeared very short depending on its parent elements.​
On mobile and smaller screens, the map and surrounding content could overflow or cause awkward scrolling, instead of resizing smoothly to fit the viewport.​​

Fixes:
A map wrapper class (for example .map-view or .full-height-map) was given a height based on the viewport (such as height: 100vh or a calculated main area height), and the inner Leaflet map container was set to height: 100% and width: 100%.​
Responsive CSS rules were added so that on wide screens the map can sit next to optional filters/details, while on smaller screens panels stack above or below the map and the map container uses max-width: 100% to avoid horizontal scrolling.​​

Explanation:
By explicitly controlling the map container’s height and using responsive CSS, the Leaflet map renders at a consistent, usable size across desktops and mobile devices, making the map view page feel like a first‑class, responsive screen in the study spot finder.

Prompt:
Add Leaflet markers for each study spot returned from the backend onto the map view, and show basic info (name and rating) in a popup when a marker is clicked.​

Issues:
The initial map only showed the base tiles with no visual indication of study spot locations.​
There was uncertainty about how to loop over an array of spots and render multiple Leaflet markers with React.​

Fixes:
The MapView component was updated to map over the study spot data and render a Marker and Popup for each item, displaying the spot’s name and key metadata.​
Marker state and props were structured so that when the backend data updates, the markers on the Leaflet map re‑render automatically.​

Explanation:
Rendering dynamic Leaflet markers from the study spot data turned the map into a functional visualization of available locations, making it easy for users to see and tap into details for each spot.​

Prompt:
Polish the map page CSS to match the app’s visual style by customizing the background, padding, and Leaflet marker appearance while keeping accessibility and responsiveness.​​

Issues:
The default Leaflet appearance did not fully match the rest of the site’s design, and spacing around the map and controls felt inconsistent with other pages.​​
Some color choices and contrast levels in the initial styling made markers and overlays harder to see on certain screens.​

Fixes:
CSS was adjusted so the map container used the same padding, fonts, and background colors as other main pages, and custom marker icons or colors were applied to better match the brand.​​
Contrast and hover/focus styles for interactive elements around the map were improved to enhance readability and accessibility across devices.​

Explanation:
Aligning the Leaflet map’s look and feel with existing app styles produced a cohesive UI, while improved contrast and responsive spacing kept the map page both attractive and usable.​​

Trent:
Prompt:
Create a frontend file structure for a studyspot app that includes a study spot details page, a favorites page, a map view page, 
login/sign-in page, and a add new studyspot page. The frontend will be created using React, Javascript, HTML, and CSS.
Create any additional files you deem necessary.

Issues:
There weren't any issues.

Fixes:
There were no fixes needed.

Explanation:
There were no issues, so there is no explanation needed.

Prompt:
Create a Favorites page that displayed the users favorited study spots.
Use a dedicated CSS file, and make the page in a similar style to MapView.js

Issues:
Received this error:
Error: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: object. You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.
Check the render method of FavoritesPage.
▶ 19 stack frames were collapsed.
This screen is visible only in development. It will not appear if the app crashes in production.
Open your browser’s developer console to further inspect this error. Click the 'X' or hit ESC to dismiss this message.

Fixes:
I fixed the issue with another prompt seen later.

Explanation:
It was important to fix this issue in order to improve robustness and the user experience. Without this change, the page would crash everytime a user tries to view their favorite study spots. By fixing this issue, the favorites page now works as intended.

Prompt:
Help me fix this error in the FavoritesPage:
Error: Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: object. You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.
Check the render method of FavoritesPage.
▶ 19 stack frames were collapsed.
This screen is visible only in development. It will not appear if the app crashes in production.
Open your browser’s developer console to further inspect this error. Click the 'X' or hit ESC to dismiss this message.

Issues:
There weren't any issues.

Fixes:
There were no fixes needed.

Explanation:
There were no issues, so there is no explanation needed.

Prompt:
Create a navigation bar in NavBar.js and NavBar.css, it should include links to the map view page, 
the favorites page, and an option to log out, and add it to the top of the favorites page.

Issues:
There weren't any issues.

Fixes:
There were no fixes needed.

Explanation:
There were no issues, so there is no explanation needed.

Prompt:
Edit AddSpotPage and LoginPage to more closely resemble the styling from MapView and Favorites

Issues:
There weren't any issues.

Fixes:
There were no fixes needed.

Explanation:
There were no issues, so there is no explanation needed.

Prompt:
Connect the Login/Register page to the backend using the endpoints https://studyspot.online/api/auth/register and https://studyspot.online/api/auth/login.

Issues:
There weren't any issues.

Fixes:
There were no fixes needed.

Explanation:
There were no issues, so there is no explanation needed.

Prompt:
Add a ratings sections, building type, and open/close hours to the studyspotdetails page and the addnewspot page.

Issues:
There weren't any issues.

Fixes:
There were no fixes needed.

Explanation:
There were no issues, so there is no explanation needed.

Jaime:
Prompt:
Ask AI to help me center the “Add study spot” form on the page and make match the format used on the map view page, using CSS changes in AddSpotPage.css

Issues:
The form container was stuck to the right side of the screen

Fixes:
Move to the left 

Explanation:
The form now appears in the correct place

Jenny: 
Prompt: add a button on the study spot card to open the details page for each study spot instead of having it so that clicking the whole card opens the detail page 

Issues: formatting of button looked different  

Fix: move the button to the bottom right corner and make the format and look match the open button

Explanation: The buttons look similar now 

Prompt: i need the study spots detail page to actually display the id specific details retrieved from the api. Calling GET to /api/spots/#spotid returns something like this:

"{
      ""id"": 1,
      ""name"": ""Accounting Library"",
      ""type"": ""Library"",
      ""hours"": ""monday: 9am-5pm""
      “isOpen”:1,
      ""rating"": 4.0,
      ""note"": ""Focused business and accounting research resources."",
      ""position"": [34.0185, -118.2840],
      ""image"": ""https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSyl29CqmGqe7riHNzxZKcnmbJIbygAm5zlRM4YmU79IW4JLr_rSaj74EEHP68f""
    },...." 
display these details on the frontend 

Issues: didn't specify to use a API helper function that was already written. Didn't specify how the hours field was a string of the hours and that there weren't open/close times specified separately. 

Fix: for open/close times, a string is returned from the backend of the times the study spot is open. just display that string as it is displayed in mapview for hours. use the function i have written in spots.js to get a spot by id 

Explanation: Using the helper function ensured the correct path was being called to retrieve from the backend 


Christine:
Prompt: Help integrate authentication into the front end to hook an existing login/signup UI to backend /api/auth/login and /api/auth/register endpoints, and store the returned token.

Issues: The original code in LoginPage.js directly called fetch inside the component, showed only stub alerts on success, and did not store any token.

Fixes: An AuthContext was created to centralize authentication state and localStorage persistence:

Explanation: Storing the token and user email in localStorage allows persistent login across page refreshes, while isLoggedIn enables protected routes.

Prompt: Attach Authorization: Bearer <token> to all subsequent API calls.

Issues: There were no issues.

Fixes: There were no fixes needed.

Explanation: Bearer <token> was attached to all subsequent API calls. 



Caleb:
AI Process Log
LLM: Claude Sonnet 4.5 (claude-sonnet-4-5-20250929)

LOOP 1: JSON Error Message Parsing
Prompt 1: "The login page isn't showing proper error messages from the backend. When I enter wrong credentials, I just see a blank error or the default message instead of the actual error from the server." 

Initial Code (LoginPage.js:63-73):
if (!res.ok) {
  const msg = await res.text().catch(() => "");
  setServerError(
    msg ||
      (mode === "login"
        ? "Invalid email or password"
        : "Could not create account")
  );
  return;
}

Prompt 2: "The backend is returning JSON error responses like {\"error\": \"Account already exists\"} but the code is trying to read them as plain text. Please update the error handling to properly parse JSON error responses and fall back to default messages if parsing fails." 

Updated Code (LoginPage.js:65-83):
if (!res.ok) {
  let errorMessage = mode === "login"
    ? "Invalid email or password"
    : "Could not create account";

  try {
    const errorData = await res.json();
    if (errorData.error) {
      errorMessage = errorData.error;
    } else if (errorData.message) {
      errorMessage = errorData.message;
    }
  } catch {
    // Use default message if JSON parsing fails
  }

  setServerError(errorMessage);
  return;
}

Explanation: The original code attempted to read error responses as plain text, which failed when the backend returned JSON. The updated code properly parses JSON error responses, checking for both error and message fields. If JSON parsing fails, it gracefully falls back to default error messages, ensuring users always see meaningful feedback.


LOOP 2: Mobile Viewport and Responsive Styling
Prompt 1: "The login page doesn't render properly on mobile devices. The viewport isn't configured correctly and the page layout breaks on smaller screens." 

Initial Code (index.html:5, components.css:6-10):
<meta name="viewport" content="width=device-width, initial-scale=1" />
html,
body,
#root {
  height: 100%;
  margin: 0;
}

Prompt 2: "Add proper viewport baseline configuration to prevent zooming issues on mobile, and add text-size-adjust properties to ensure consistent font rendering across devices. Also improve the error banner styling for better readability on small screens." 

Updated Code (index.html:5, components.css:6-23, 89):
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0" />
html {
  font-size: 16px;
  height: 100%;
  margin: 0;
  -webkit-text-size-adjust: 100%;
  -moz-text-size-adjust: 100%;
  text-size-adjust: 100%;
}

body,
#root {
  height: 100%;
  margin: 0;
}

/* ... */

.error-banner { 
  margin-bottom: 0.75rem; 
  padding: 0.6rem 0.75rem; 
  border-radius: 10px; 
  background: #fef2f2; 
  color: #991b1b; 
  border: 1px solid #fecaca; 
  font-size: 0.9rem; 
}

Explanation: The initial viewport meta tag lacked minimum-scale constraints, causing zoom issues on mobile browsers. The updated configuration adds minimum-scale and proper decimal values for initial-scale. CSS improvements include explicit HTML font-size baseline, text-size-adjust properties to prevent automatic font scaling, and improved error banner font sizing for mobile readability.


KT
Prompt: Implement secure login system and enable guest and authenticated functionality

Issues:
The backend had no authentication flow: passwords were not hashed, users couldn’t log in, and the system couldn’t distinguish guest users from authenticated users. The frontend also had no way to store or send auth tokens.

Fixes:
Added the /api/auth/login endpoint, implemented input validation, and verified user credentials using BCrypt. Integrated JWT generation with a 24-hour expiration and connected it to frontend storage through the Authorization: Bearer <token> header. Added error handling for invalid credentials and set up the backend to determine user access based on token validity.

Explanation:
This established a login system that securely authenticates users and enables the app to enforce different functionality for guests and logged-in users.

Prompt2: Add GET review endpoint for study spots

Issues:
Study spots had no way to display user reviews. The backend lacked an endpoint to fetch reviews, and there was no ordering or DTO structure to safely return review data without lazy-loading issues.

Fixes:
Implemented GET /api/spots/{spotId}/reviews, returning reviews ordered newest-first. Added a repository method findByStudySpotIdOrderByCreatedAtDesc and introduced a lightweight DTO including review id, rating, comment, timestamp, and the reviewer’s user id and username. Controller now exposes the public GET route under /api.

Explanation:
This enables the frontend to display all reviews for a study spot with consistent formatting and correct ordering. The endpoint works publicly but still flows through global security config, meaning additional adjustments can be made later if full public access is required.

Kasra
Prompt: Initialize backend structure and create the first StudySpot + User API routes

Issues:
The backend folder only contained a skeleton Maven project with no functional APIs. There was no database connection, no entities for StudySpot or User, and developers could not test any backend features from the frontend. Docker configuration also wasn’t aligned with the service names used in the project.

Fixes:
Set up the Spring Boot backend project structure (src/), added a docker-compose.yml for MySQL + backend containers, and configured .env.example for DB credentials. Implemented the initial StudySpot API and created the User table along with a simple user API endpoint. Updated .gitignore and backend wrapper files to support local development.

Explanation:
These changes established the full backend foundation so new features could be built incrementally. With the base API in place and the database running through Docker, the team could begin integrating login, study spot features, and frontend connections.



